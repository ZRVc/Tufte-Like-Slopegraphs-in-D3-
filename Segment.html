<!DOCTYPE html>
<html>
<body>

<h1>Array includes()</h1>

<p>Check if the fruit array contains "Mango":</p>

<p id="demo"></p>

<p><strong>Note:</strong> The includes method is not supported in Edge 13 (and earlier versions).</p>

<script>
var nrow = 30;
var highlight = [3,12];

var linecolor = "red";
var textcolor = "black";

function Arrayfill(item, times) {
  	var arr = [];
 	 for (var i = 0; i < times; i++) {
   	 arr.push(item);
  	}
 	 return arr;
	}

var linecolors = Arrayfill(linecolor,nrow);
var numcolors1 = Arrayfill(textcolor,nrow);
var numcolors2 = numcolors1
var textcolors1 = Arrayfill(textcolor,nrow);
var textcolors2 = textcolors1;


function highlighter(item, times, highlight) { 
for (var i = 0; i < times; i++) {
   	 
if (highlight.includes(i)) {
item[i] = "orange";
  	}
}
 	 return item;
	}

textcolors1 = highlighter(textcolors1,nrow,highlight)

document.getElementById("demo").innerHTML = textcolors1;

</script>

</body>
</html>



# Get the data
tufte2 <- read.csv("https://raw.githubusercontent.com/ZRVc/Tufte-Style-Slopegraphs-in-D3-/master/Basket.csv")

## "space" sets the line spacing.  It is the minimum distance between labels.
## "drop" controls the slope.

space <- 16
drop <- 24

## Set the constraints:  
constr <- c(1,2,3,4)

## Set the tolerance for the slopes: 
slopetol <- 0.00001

equalitytol <- 0.001

## Decide whether or not the order should be preserved (both columns)
pres_ord <- c(FALSE,FALSE)

## The package "ROI" needs to be installed.
# install.packages("ROI")
# install.packages("alabama")
# install.packages("numDeriv")
# install.packages("ROI.plugin.alabama")

library(ROI)
library(ROI.plugin.alabama)
library("alabama")

x <- c(tufte2[,2],tufte2[,3])

x <- list(x[1:(length(x)/2)], x[((length(x)/2)+1):length(x)])

## Finding the ties
tiedpoints1 <- which(x[[1]] %in% x[[1]][duplicated(x[[1]])])
tiedpoints2 <- which(x[[2]] %in% x[[2]][duplicated(x[[2]])])
tiedpoints <- list(tiedpoints1, tiedpoints2)

## This will set the slope so that a one unit decrease in x
## corresponds to a "drop" pixel drop on the page.
y1 <- drop*(max(c(x[[1]],x[[2]])) - x[[1]])
y2 <- (y1 - drop*(x[[2]]-x[[1]]))

## This will be the...
y_start <- c(y1,y2)

## Finding the minimum non-zero difference between the points
min_diff_finder <- function(y,x0=x) {
  
  y <- list(y[1:(length(y)/2)], y[(length(y)/2+1):length(y)])
  diff <- Inf
  
  for(c in 1:2){
    index <- which(!duplicated(x0[[c]]))
    for(i in 1:(length(index)-1)) {
      for(j in (i+1):length(index)) {
        if (abs(y[[c]][index[i]]-y[[c]][index[j]]) < diff) {
          diff <- abs(y[[c]][index[i]]-y[[c]][index[j]])
        }
      }
    }
  }
  return(diff)
}

## Find the minimum non-zero distance points can be moved without altering perspective
min_persp_change_finder <- function(y, x0=x){
  y <- list(y[1:(length(y)/2)], y[(length(y)/2+1):length(y)])
  
for(c in 1:2) {
  index <- which(!duplicated(x0[[c]]))
  
  x_h <- x0[[c]][index][1:(length(index)-2)]
  x_m <- x0[[c]][index][2:(length(index)-1)]
  x_l <- x0[[c]][index][3:(length(index))]
  
  y_h <- y[[c]][index][1:(length(index)-2)]
  y_m <- y[[c]][index][2:(length(index)-1)]
  y_l <- y[[c]][index][3:(length(index))]
}
 return(min(abs(2*y_m-y_h-y_l)[which(2*x_m-x_h-x_l > 0)]))
}

spreadtol <- min(min_diff_finder(y_start),min_persp_change_finder(y_start))

########################################################################## Objective Functions
## The final objective function.  This is the function I'm trying to optimize.
fn <- function(v,z){
  return(sum((z-v)^2))
}
gr <- function(v,z){
  return(2*v-2*z)
}

## Wrapper functions to work with ROI
fn1 <- function(y) {
  return(fn(y,z=y_start))
}
gr1 <- function(y) {
  return(gr(y,z=y_start))
}

### First objective function
beginfn <- function(v,x0=x,z=y_start) {
  
  rid <- c(0,0)
  gain <- c(0,0)
  
  for(c in 1:2) {
    if(length(tiedpoints[[c]]) > 0) {
      tieloc <- unique(x0[[c]][duplicated(x0[[c]])])
      tiegroup <- 0
      for(n in tieloc) {
        tiegroup <- c(tiegroup,list(which(x0[[c]] == n)))
      }
      
      tiegroup <- tiegroup[2:length(tiegroup)]
      
      rid[c] <- sum((z[tiedpoints[[c]]]-v[tiedpoints[[c]]])^2)
      for(i in 1:length(tieloc)) {
        for(j in 1:(length(tiegroup[[i]])-1)) {
          for (k in 2:length(tiegroup[[i]])) {
            gain[c] <- gain[c] + (v[tiegroup[[i]][j]]-v[tiegroup[[i]][k]])^2
          }
        }
      }
    }
  }
  return(sum((z-v)^2)-sum(rid)-sum(gain))
}

## First gradient
begingr <- function(v,z=y_start,x0=x,tiedpoints0=tiedpoints) {
  w <- 2*v-2*z
  
  for(c in 1:2) {
    if(length(tiedpoints[[c]]) > 0) {
      tieloc <- unique(x0[[c]][duplicated(x0[[c]])])
      tiegroup <- 0
      for(n in tieloc) {
        tiegroup <- c(tiegroup,list(which(x0[[c]] == n)))
      }
      tiegroup <- tiegroup[2:length(tiegroup)]
      
      for(i in 1:length(tieloc)) {
        for(j in tiegroup[[i]]) {
          index <- tiegroup[[i]][which(tiegroup[[i]] != j)]
          w[j] <- 2*sum(v[index])-2*(length(tiegroup[[i]])-1)*v[j]
        }
      }
    }
  }
  return(w)
}

## Wrappers
beginfn1 <- function(y) {
  return(beginfn(y,z=y_start))
}

begingr1 <- function(y) {
  return(begingr(y,z=y_start))
}

###################################################################################### Constraints
## Slope constraints
slope_ineq <- function(y,x0=x,s_tol=slopetol) {
  
  x1 <- x0[[1]]
  x2 <- x0[[2]]
  
  index1 <- 0
  for(i in 1:length(x1)){
    if(x1[i]!=x2[i]){
      index1 <- c(index1,i)
    }
  }
  index1 <- index1[2:length(index1)]
  index2 <- subset((1:length(x1)),!((1:length(x1)) %in% index1))
  
  u <- rep(0,length(y))
  v1 <- 0
  v2 <- 0
  
  for(i in 1:(length(index1)-1)) {
    w1 <- rep(0,length(y))
    w1[index1[i]] <- 1/(x1[index1[i]]-x2[index1[i]])
    w1[index1[(i+1)]] <- -1/(x1[index1[(i+1)]]-x2[index1[(i+1)]])
    w1[(index1[i]+(length(y)/2))] <- -1/(x1[index1[i]]-x2[index1[i]])
    w1[(index1[i]+(length(y)/2+1))] <- 1/(x1[index1[(i+1)]]-x2[index1[(i+1)]])
    
    u <- rbind(u,w1,w1)
    v1 <- append(v1,c(1,2),after=length(v1))
    v2 <- append(v2,c(-s_tol,s_tol),after=length(v2)) 
  }
  
  if(length(index2) > 0){
    for(i in 1:length(index2)) {
      w2 <- rep(0,length(y))
      w2[index2[i]] <- 1
      w2[(index2[i]+(length(y)/2))] <- -1
      
      u <- rbind(u,w2,w2)
      v1 <- append(v1,c(1,2),after=length(v1))
      v2 <- append(v2,c(-s_tol,s_tol),after=length(v2)) 
    }
  }    
  
  umod <- u[2:dim(u)[1],]
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}


## Initial perspective constraints
ini_persp_ineq <- function(y,x0=x, tol=spreadtol, colmn, etol=equalitytol,tiedpoints0 = tiedpoints) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
    tiedpoints3 <- tiedpoints0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
    tiedpoints3 <- tiedpoints0[[2]]
  }
  
  index <- which(x3 %in% subset(x3, min(x3) < x3 & max(x3) > x3))
  
  u <- rep(0,length(y)/2)
  v1 <- 0
  v2 <- 0 
  
  for(m in index) {
    w <- rep(0,(length(y)/2))
    lowerpts <- which(x3 < x3[m])
    higherpts <- which(x3 > x3[m])
    l <- min(which(x3 == max(x3[lowerpts])))
    h <- max(which(x3 == min(x3[higherpts])))
    if(m %in% tiedpoints3) {
      if(l %in% tiedpoints3 && !(h %in% tiedpoints3)) {
        w[l] <- 0
        w[h] <- 1
        w[m] <- 0
        if(x3[h] - x3[m] == x3[m] - x3[l]) {
          u <- rbind(u,w,w)
          v1 <- append(v1,c(1,2),after=length(v1))
          v2 <- append(v2,c(2*y3[m]-y3[l]+tol-etol,2*y3[m]-y3[l]+tol+etol),after=length(v2)) 
        } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,2*y3[m]-y3[l]+tol,after=length(v2))
        } else {
          u <- rbind(u,w)
          v1 <- append(v1,2,after=length(v1))
          v2 <- append(v2,2*y3[m]-y3[l]+tol,after=length(v2))
        }
      } else if(h %in% tiedpoints3 && !(l %in% tiedpoints3)) {
        w[l] <- 1
        w[h] <- 0
        w[m] <- 0
        if(x3[h] - x3[m] == x3[m] - x3[l]) {
          u <- rbind(u,w,w)
          v1 <- append(v1,c(1,2),after=length(v1))
          v2 <- append(v2,c(2*y3[m]-y3[h]-tol-etol,2*y3[m]-y3[h]-tol+etol),after=length(v2))
        } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,2*y3[m]-y3[h]-tol,after=length(v2))
        } else {
          u <- rbind(u,w)
          v1 <- append(v1,2,after=length(v1))
          v2 <- append(v2,2*y3[m]-y3[h]-tol,after=length(v2))
        }
      } else if(!(h %in% tiedpoints3) && !(l %in% tiedpoints3)) {
        w[l] <- 1
        w[h] <- 1
        w[m] <- 0
        if(x3[h] - x3[m] == x3[m] - x3[l]) {
          u <- rbind(u,w,w)
          v1 <- append(v1,c(1,2),after=length(v1))
          v2 <- append(v2,c(2*y3[m]-etol,2*y3[m]+etol),after=length(v2))
        } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,2*y3[m],after=length(v2))
        } else {
          u <- rbind(u,w)
          v1 <- append(v1,2,after=length(v1))
          v2 <- append(v2,2*y3[m],after=length(v2))
        }
      }
    } else {
      if(l %in% tiedpoints3) {
        if(h %in% tiedpoints3) {
          w[l] <- 0
          w[h] <- 0
          w[m] <- 2
          if(x3[h] - x3[m] == x3[m] - x3[l]) {
            u <- rbind(u,w,w)
            v1 <- append(v1,c(1,2),after=length(v1))
            v2 <- append(v2,c(y3[h]+y3[l]-etol,y3[h]+y3[l]+etol),after=length(v2)) 
          } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
            u <- rbind(u,w)
            v1 <- append(v1,2,after=length(v1))
            v2 <- append(v2,y3[h]+y3[l],after=length(v2))
          } else {
            u <- rbind(u,w)
            v1 <- append(v1,1,after=length(v1))
            v2 <- append(v2,y3[h]+y3[l],after=length(v2))
          }
        } else {
          w[l] <- 0
          w[h] <- -1
          w[m] <- 2
          if(x3[h] - x3[m] == x3[m] - x3[l]) {
            u <- rbind(u,w,w)
            v1 <- append(v1,c(1,2),after=length(v1))
            v2 <- append(v2,c(y3[l]-tol-etol,y3[l]-tol+etol),after=length(v2)) 
          } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
            u <- rbind(u,w)
            v1 <- append(v1,2,after=length(v1))
            v2 <- append(v2,y3[l]-tol,after=length(v2)) 
          } else {
            u <- rbind(u,w)
            v1 <- append(v1,1,after=length(v1))
            v2 <- append(v2,y3[l]-tol,after=length(v2)) 
          }
        }
      } else if(h %in% tiedpoints3) {
        w[l] <- -1
        w[h] <- 0
        w[m] <- 2
        if(x3[h] - x3[m] == x3[m] - x3[l]) {
          u <- rbind(u,w,w)
          v1 <- append(v1,c(1,2),after=length(v1))
          v2 <- append(v2,c(y3[h]+tol-etol,y3[h]+tol+etol),after=length(v2))
        } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
          u <- rbind(u,w)
          v1 <- append(v1,2,after=length(v1))
          v2 <- append(v2,y3[h]+tol,after=length(v2))
        } else {
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,y3[h]+tol,after=length(v2))
        }
      } else {
        w[l] <- -1
        w[h] <- -1
        w[m] <- 2
        if(x3[h] - x3[m] == x3[m] - x3[l]) {
          u <- rbind(u,w,w)
          v1 <- append(v1,c(1,2),after=length(v1))
          v2 <- append(v2,c(-etol,etol),after=length(v2))
        } else if(x3[h] - x3[m] < x3[m] - x3[l]) {
          u <- rbind(u,w)
          v1 <- append(v1,2,after=length(v1))
          v2 <- append(v2,0,after=length(v2)) 
        } else {
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,0,after=length(v2)) 
        }
      }
    }
  }
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}


## Final perspective constraints
fin_persp_ineq <- function(y,x0=x, colmn, tiedpoints0 = tiedpoints) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
    tiedpoints3 <- tiedpoints0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
    tiedpoints3 <- tiedpoints0[[2]]
  }
  
  index <- which(x3 %in% subset(x3, min(x3) < x3 & max(x3) > x3 & !(x3 %in% x3[tiedpoints3])))
  
  u <- rep(0,length(y)/2)
  v1 <- 0
  v2 <- 0 
  
  if(length(tiedpoints3) > 0) {
    tieloc <- unique(x3[duplicated(x3)])
    tiegroup <- 0
    for(i in tieloc) {
      tiegroup <- c(tiegroup,list(which(x3 == i)))
    }
    tiegroup <- tiegroup[2:length(tiegroup)]
  }
  
  for(m in index) {
    w <- rep(0,(length(y)/2))
    lowerpts <- which(x3 < x3[m])
    higherpts <- which(x3 > x3[m])
    l <- min(which(x3 == max(x3[lowerpts])))
    h <- max(which(x3 == min(x3[higherpts])))
    
    if(!(h %in% tiedpoints3) && !(l %in% tiedpoints3)) {
      w[l] <- -1
      w[h] <- -1
      w[m] <- 2
      
      if(x3[h] - x3[m] < x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,2,after=length(v1))
        v2 <- append(v2,0,after=length(v2)) 
      }
      else if(x3[h] - x3[m] > x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,1,after=length(v1))
        v2 <- append(v2,0,after=length(v2))
      }
      
    } else if(h %in% tiedpoints3 && !(l %in% tiedpoints3)) {
      
      hightie <- which(tieloc==x3[h])
      tielenh <- length(tiegroup[[hightie]])
      
      w[l] <- -1
      for(k in tiegroup[[hightie]]) {
        w[k] <- -1/tielenh
      }
      w[m] <- 2
      
      if(x3[h] - x3[m] < x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,2,after=length(v1))
        v2 <- append(v2,space*(tielenh-1)/2,after=length(v2)) 
      }
      else if(x3[h] - x3[m] > x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,1,after=length(v1))
        v2 <- append(v2,space*(tielenh-1)/2,after=length(v2))
      }
    } else if (l %in% tiedpoints3 && !(h %in% tiedpoints3)) {
      
      lowtie <- which(tieloc==x3[l])
      tielenl <- length(tiegroup[[lowtie]])
      
      for(k in tiegroup[[lowtie]]) {
        w[k] <- 1/tielenl
      }
      w[h] <- 1
      w[m] <- -2
      
      if(x3[h] - x3[m] < x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,1,after=length(v1))
        v2 <- append(v2,space*(tielenl-1)/2,after=length(v2)) 
      }
      else if(x3[h] - x3[m] > x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,2,after=length(v1))
        v2 <- append(v2,space*(tielenl-1)/2,after=length(v2))
      }
    } else {
      
      lowtie <- which(tieloc==x3[l])
      tielenl <- length(tiegroup[[lowtie]])
      
      hightie <- which(tieloc==x3[h])
      tielenh <- length(tiegroup[[hightie]])
      
      for(k in tiegroup[[lowtie]]) {
        w[k] <- -1/tielenl
      }
      for(n in tiegroup[[hightie]]) {
        w[n] <- -1/tielenh
      }
      w[m] <- 2
      
      if(x3[h] - x3[m] < x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,2,after=length(v1))
        v2 <- append(v2,space*((tielenh-1)-(tielenl-1))/2,after=length(v2)) 
      }
      else if(x3[h] - x3[m] > x3[m] - x3[l]) {
        u <- rbind(u,w)
        v1 <- append(v1,1,after=length(v1))
        v2 <- append(v2,space*((tielenh-1)-(tielenl-1))/2,after=length(v2))
      }
    }
  }
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}

## Linear separating constraints
ini_sep_ineqL <- function(y, x0=x, tol2=spreadtol, colmn, tiedpoints0=tiedpoints) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
    tiedpoints3 <- tiedpoints0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
    tiedpoints3 <- tiedpoints0[[2]]
  }
  
  u <- rep(0,length(y3))
  v1 <- 0
  v2 <- 0
  
  if(length(tiedpoints3) > 0) {
    tieloc <- unique(x3[duplicated(x3)])
    tiegroup <- 0
    
    for(i in tieloc) {
      tiegroup <- c(tiegroup,list(which(x3 == i)))
    }
    tiegroup <- tiegroup[2:length(tiegroup)]
  }
  
  minnum <- length(which(x3==min(x3)))
  
  for(i in order(x3,decreasing=T)[1:length(x3)]) {
    if(i %in% tiedpoints3) {
      w <- rep(0,length(y3))
      w[i] <- 1
      u <- rbind(u,w,w)
      v1 <- append(v1,c(1,2),after=length(v1))
      v2 <- append(v2,c(y3[i]-tol2,y3[i]+tol2),after=length(v2))
      
      tie <- which(tieloc==x3[i])
      tielen <- length(tiegroup[[tie]])
      if(i < max(tiegroup[[tie]])) {
        for(j in tiegroup[[tie]][(which(tiegroup[[tie]] > i))]) {
          w <- rep(0,length(y3))
          w[i] <- -1
          w[j] <- 1
          u <- rbind(u,w)
          v1 <- append(v1,1,after=length(v1))
          v2 <- append(v2,0,after=length(v2))
        }
      }
    }
  }
  for(i in order(x3,decreasing=T)[1:(length(x3)-minnum)]) {
    index2 <- which(x3 == max(x3[which(x3 < x3[i])]))
    w <- rep(0,length(y3))
    if(length(index2) > 1) {
      w[i] <- 1
      u <- rbind(u,w)
      v1 <- append(v1,2,after=length(v1))
      v2 <- append(v2,y3[index2[1]]-tol2,after=length(v2))
    } else {
      w[i] <- -1
      w[index2] <- 1
      u <- rbind(u,w)
      v1 <- append(v1,1,after=length(v1))
      v2 <- append(v2,0,after=length(v2))
    }
  }
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}

## Quadratic separating constraints
ini_sep_ineqQ <- function(y, x0=x, tol2=spreadtol, colmn, tiedpoints0=tiedpoints) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
    tiedpoints3 <- tiedpoints0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
    tiedpoints3 <- tiedpoints0[[2]]
  }
  
  u <- rep(0,length(y3))
  v1 <- 0
  v2 <- 0
  
  minnum <- length(which(x3==min(x3)))
  
  for(i in order(x3,decreasing=T)[1:(length(x3)-minnum)]) {
    w <- rep(0,length(y3))
    if(i %in% tiedpoints3) {
      w[i] <- 1
      u <- rbind(u,w,w)
      v1 <- append(v1,c(1,2),after=length(v1))
      v2 <- append(v2,c(y3[i]-tol2,y3[i]+tol2),after=length(v2))
    } 
    index2 <- which(x3 == max(x3[which(x3 < x3[i])]))
    if(length(index2) > 1) {
      w[i] <- 1
      u <- rbind(u,w)
      v1 <- append(v1,2,after=length(v1))
      v2 <- append(v2,y3[index2[1]]-tol2,after=length(v2))
    } else {
      w[i] <- -1
      w[index2] <- 1
      u <- rbind(u,w)
      v1 <- append(v1,1,after=length(v1))
      v2 <- append(v2,0,after=length(v2))
    }
  }
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}

## Linear spacing constraints
spacing_ineqL <- function(y,x0=x,colmn,space0=space) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
  }
  
  u <- rep(0,length(y3))
  v1 <- 0
  v2 <- 0
  
  for(i in 1:(length(y3)-1)) {
    w <- rep(0,length(y3))
    j <- min(which(y3 == min(y3[which(y3 > y3[i])])))
    
    w[i] <- -1
    w[j] <- 1
    
    u <- rbind(u,w)
    v1 <- append(v1,1,after=length(v1))
    v2 <- append(v2,space0,after=length(v2))
  }
  
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  return(unname(cbind(umod,v1mod,v2mod)))
}

## Quadratic spacing constraints
spacing_ineqQ <- function(y,x0=x,colmn,tiedpoints0=tiedpoints,space0=space) {
  
  if(colmn == 1){
    y3 <- y[1:(length(y)/2)]
    x3 <- x0[[1]]
    tiedpoints3 <- tiedpoints0[[1]]
  }
  if(colmn == 2){
    y3 <- y[(length(y)/2+1):length(y)]
    x3 <- x0[[2]]
    tiedpoints3 <- tiedpoints0[[2]]
  }
  
  u <- rep(0,length(y3))
  v1 <- 0
  v2 <- 0
  q <- 0
  
  minnum <- length(which(x3==min(x3)))
  
  for(i in order(x3,decreasing=T)[1:(length(x3)-minnum)]) {
    w <- rep(0,length(y3))
    index2 <- min(which(x3 == max(x3[which(x3 < x3[i])])))
    w[i] <- -1
    w[index2] <- 1
    u <- rbind(u,w)
    v1 <- append(v1,1,after=length(v1))
    v2 <- append(v2,space0,after=length(v2))
    q <- c(q,list(NULL))
  }
  for(j in unique(x3[tiedpoints3])) {
    grp <- which(x3 == j)
    for(k in 1:(length(grp)-1)) {
      for(m in (k+1):length(grp)) {
        wq <- matrix(0, nrow=length(y3), ncol=length(y3))
        wq[grp[k],grp[k]] <- 2 
        wq[grp[k],grp[m]] <- -2
        wq[grp[m],grp[m]] <- 2
        wq[grp[m],grp[k]] <- -2
        u <- rbind(u,rep(0,length(y3)))
        v1 <- append(v1,1,after=length(v1))
        v2 <- append(v2,space0^2,after=length(v2))
        
        if(colmn == 1){
          wq <- cbind(wq,matrix(0,nrow=length(y3),ncol=length(y3)))
          wq <- rbind(wq,matrix(0,nrow=length(y3),ncol=length(y)))
        }
        
        if(colmn == 2){
          wq <- cbind(matrix(0,nrow=length(y3),ncol=length(y3)),wq)
          wq <- rbind(matrix(0,nrow=length(y3),ncol=length(y)),wq)
        }
        q <- c(q,list(wq))
      }
    }
  }
  if(colmn == 1){
    umod <- cbind(u[2:dim(u)[1],],matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2))
  }
  if(colmn == 2){
    umod <- cbind(matrix(0,nrow=dim(u)[1]-1,ncol=length(y)/2),u[2:dim(u)[1],])
  }
  
  v1mod <- v1[2:length(v1)]
  v2mod <- v2[2:length(v2)]
  
  q <- q[2:length(q)]
  
  l <- unname(cbind(umod,v1mod,v2mod))
  return(list(q,l))
}

########################################################## The first problem
inequalitymaker1 <- function(y,pres_ord0 = pres_ord) {
  
  iq <- rep(0,(length(y)+2))
  
  iq <- rbind(iq,slope_ineq(y))
  iq <- rbind(iq,ini_persp_ineq(y,colmn=1))
  iq <- rbind(iq,ini_persp_ineq(y,colmn=2))

    for(i in 1:2) {
      if(pres_ord0[i] == FALSE) {
        iq <- rbind(iq,ini_sep_ineqQ(y,colmn=i))
      } else {
        iq <- rbind(iq,ini_sep_ineqL(y,colmn=i))
      }
    }
  
  iq <- iq[2:length(iq[,1]),]
  
  dir1 <- iq[,(length(y)+1)]
  dir1[which(dir1 == 1)] <- ">="
  dir1[which(dir1 == 2)] <- "<="
  
  rhs1 <- iq[,(length(y)+2)]
  
  iq <- iq[,1:length(y)]
  
  return(L_constraint(L=iq, dir=dir1, rhs=rhs1))
}

## The first problem
fo1 <-  F_objective(F=beginfn1,n=length(y_start),G=begingr1)
lc1 <- inequalitymaker1(y_start)
prob1 <- OP(fo1,lc1)

## The first solution
sol1 <- ROI_solve(prob1,solver="alabama",start=y_start)

## The first solution
newstart <- solution(sol1)

min_diff_finder2 <- function(y) {

y <- list(y[1:(length(y)/2)], y[(length(y)/2+1):length(y)])

diff <- Inf

for(c in 1:2) {
  for(i in 1:(length(y[[c]])-1)) {
    for(j in (i+1):length(y[[c]])) {
      if (abs(y[[c]][i]-y[[c]][j]) < diff) {
        diff <- abs(y[[c]][i]-y[[c]][j])
      }
    }
  }
} 
return(diff)
}

scaler <- min_diff_finder2(newstart)

newstart1 <- newstart*(space*1.1/scaler)

########################################################## The second problem
inequalitymaker2 <- function(y, constr0=constr, pres_ord0=pres_ord) {
  
  iq <- rep(0,(length(y)+2))
  
  if(1 %in% constr0) {
    iq <- rbind(iq,slope_ineq(y))
  }
  if(3 %in% constr0) {
    iq <- rbind(iq,unname(fin_persp_ineq(y,colmn=1)))
  }
  if(4 %in% constr0) {
    iq <- rbind(iq,unname(fin_persp_ineq(y,colmn=2)))
  }
  
   if (sum(pres_ord0) < 2) {
    q <- rep(list(NULL),(length(iq[,1])))
    
    for(i in 1:2) {
      if(pres_ord0[i] == FALSE) {
    iq <- rbind(iq,unname(spacing_ineqQ(y,colmn=i)[[2]]))
    q <- c(q,unname(spacing_ineqQ(y,colmn=i)[[1]]))
      } else {
        iq <- rbind(iq,unname(spacing_ineqL(y,colmn=i)))
        q <- c(q,rep(list(NULL),length(unname(spacing_ineqL(y,colmn=i))[,1])))
      }
    }
    iq <- iq[2:length(iq[,1]),]
    q <- q[2:length(q)]
    
    dir1 <- iq[,(length(y)+1)]
    dir1[which(dir1 == 1)] <- ">="
    dir1[which(dir1 == 2)] <- "<="
    
    rhs1 <- iq[,(length(y)+2)]
    
    iq <- iq[,1:length(y)]

    return(Q_constraint(Q=q, L=iq, dir=dir1, rhs=rhs1))
   } else {
    iq <- rbind(iq,unname(spacing_ineqL(y,colmn=1)))
    iq <- rbind(iq,unname(spacing_ineqL(y,colmn=2)))
    
    iq <- iq[2:length(iq[,1]),]
    
    dir1 <- iq[,(length(y)+1)]
    dir1[which(dir1 == 1)] <- ">="
    dir1[which(dir1 == 2)] <- "<="
    
    rhs1 <- iq[,(length(y)+2)]
    
    iq <- iq[,1:length(y)]

    return(L_constraint(L=iq, dir=dir1, rhs=rhs1))
  }
}

fo2 <-  F_objective(F=fn1,n=length(newstart1),G=gr1)
lc2 <- inequalitymaker2(newstart1)
prob2 <- OP(fo2,lc2)
sol2 <- ROI_solve(prob2,solver="alabama",start=newstart1)

points0 <- round(solution(sol2)-min(solution(sol2)),2)

points1 <- points0[1]
for(i in 2:(length(points0)/2)) {
  points1 <- paste(points1,points0[i],sep = ", ")
}

points2 <- points0[(length(points0)/2+1)]
for(i in (length(points0)/2+2):length(points0)) {
  points2 <- paste(points2,points0[i],sep = ", ")
}

## The solution, formatted for pasting into D3.js
points1
points2

## Check the slopes
y1Solve <- round(solution(sol2)-min(solution(sol2)),2)[1:(length(solution(sol2))/2)]
y2Solve <- round(solution(sol2)-min(solution(sol2)),2)[(length(solution(sol2))/2+1):length(solution(sol2))]

(y2Solve-y1Solve)/(x[[2]]-x[[1]])


